<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Protomaps Evaluation — MapLibre GL JS Demo</title>
  <!-- MapLibre GL JS — primary rendering library -->
  <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@5/dist/maplibre-gl.css">
  <style>
    body { margin: 0; padding: 0; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1;
      background: white;
      border-radius: 4px;
      padding: 8px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.3);
      font-family: sans-serif;
      font-size: 14px;
    }
    #controls label {
      display: block;
      padding: 4px 0;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="controls">
    <strong>Style</strong>
    <label><input type="radio" name="style" value="light" checked> Light</label>
    <label><input type="radio" name="style" value="dark"> Dark</label>
    <label><input type="radio" name="style" value="grayscale"> Grayscale</label>
    <label><input type="radio" name="style" value="zen"> Zen</label>
    <label><input type="radio" name="style" value="toner"> Toner</label>
    <label><input type="radio" name="style" value="apollo-bright"> Apollo Bright</label>
    <hr style="margin: 4px 0;">
    <strong>Layers</strong>
    <label><input type="checkbox" id="toggle-labels" checked> Labels</label>
    <label><input type="checkbox" id="toggle-pois" checked> POIs</label>
    <label><input type="checkbox" id="toggle-airports" checked> Airports</label>
    <label><input type="checkbox" id="toggle-3d"> 3D Buildings</label>
    <hr style="margin: 4px 0;">
    <strong>View</strong>
    <label><input type="radio" name="view" value="2d" checked> 2D</label>
    <label><input type="radio" name="view" value="3d"> 3D</label>
    <label style="display: flex; align-items: center; gap: 6px;">Pitch <input type="range" id="pitch-slider" min="0" max="70" value="0" style="width: 80px;"></label>
    <label style="display: flex; align-items: center; gap: 6px;">Bearing <input type="range" id="bearing-slider" min="0" max="360" value="0" style="width: 80px;"></label>
  </div>

  <!-- PMTiles — client-side protocol handler for range-request tile fetching -->
  <script src="https://unpkg.com/maplibre-gl@5/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/pmtiles@4/dist/pmtiles.js"></script>
  <!-- Protomaps basemaps — programmatic style generation for Tilezen schema -->
  <script src="https://unpkg.com/@protomaps/basemaps@5/dist/basemaps.js"></script>
  <script>
    // Protomaps daily planet build — world coverage, zoom 0–15
    // See https://maps.protomaps.com/builds/ for available builds
    var PMTILES_URL = 'http://localhost:8080/tiles/latest.pmtiles';

    // Register the PMTiles protocol so MapLibre can fetch tiles via range requests
    var protocol = new pmtiles.Protocol({ metadata: true });
    maplibregl.addProtocol('pmtiles', protocol.tile);

    // Building colors per flavor (matching basemaps defaults)
    var BUILDING_COLORS = {
      light: { fill: '#cccccc', extrusion: '#ddd' },
      dark:  { fill: '#111111', extrusion: '#222' },
      grayscale: { fill: '#c0c0c0', extrusion: '#ccc' }
    };

    var buildings3dEnabled = false;

    // Apollo Mapping Tilezen styles — loaded from local JSON files
    var APOLLO_STYLES = {
      'zen': 'styles/zen.json',
      'toner': 'styles/toner.json',
      'apollo-bright': 'styles/apollo-bright.json'
    };
    var APOLLO_RESOURCE_URL = 'https://s3-us-west-1.amazonaws.com/osm-vector-tiles-apollomapping';
    var apolloStyleCache = {};

    function loadApolloStyle(name) {
      if (apolloStyleCache[name]) {
        return Promise.resolve(JSON.parse(JSON.stringify(apolloStyleCache[name])));
      }
      return fetch(APOLLO_STYLES[name])
        .then(function (r) { return r.text(); })
        .then(function (text) {
          // Replace templates in raw JSON text before parsing
          text = text.replace(/\{resource_url\}/g, APOLLO_RESOURCE_URL);
          text = text.replace(/\{localization_name\}/g, '{name:en}');
          var style = JSON.parse(text);
          // Replace template source with PMTiles source
          style.sources = {
            osm: {
              type: 'vector',
              url: 'pmtiles://' + PMTILES_URL,
              attribution: '\u00a9 <a href="https://openstreetmap.org">OpenStreetMap</a> · <a href="https://protomaps.com">Protomaps</a>'
            }
          };
          // Apollo Bright: drop the natural_earth raster layer (external tile server)
          if (name === 'apollo-bright') {
            style.layers = style.layers.filter(function (layer) {
              return layer.id !== 'natural_earth';
            });
          }
          apolloStyleCache[name] = style;
          return style;
        });
    }

    function isApolloStyle(name) {
      return name in APOLLO_STYLES;
    }

    // Build a complete MapLibre style object for a given Protomaps flavor
    function buildStyle(flavorName) {
      var layers = basemaps.layers('protomaps', basemaps.namedFlavor(flavorName), { lang: 'en' });

      if (buildings3dEnabled) {
        var colors = BUILDING_COLORS[flavorName] || BUILDING_COLORS.light;
        // Replace the flat "buildings" fill layer with flat + extrusion pair
        layers = layers.reduce(function (acc, layer) {
          if (layer.id === 'buildings') {
            // Flat fill for z13-14 (before extrusion kicks in)
            acc.push({
              id: 'buildings',
              type: 'fill',
              source: 'protomaps',
              'source-layer': 'buildings',
              maxzoom: 14,
              filter: ['in', 'kind', 'building', 'building_part'],
              paint: { 'fill-color': colors.fill, 'fill-opacity': 0.5 }
            });
            // 3D extrusion for z14+
            acc.push({
              id: 'buildings-3d',
              type: 'fill-extrusion',
              source: 'protomaps',
              'source-layer': 'buildings',
              minzoom: 14,
              filter: ['in', 'kind', 'building', 'building_part'],
              paint: {
                'fill-extrusion-color': colors.extrusion,
                'fill-extrusion-height': ['coalesce', ['get', 'height'], 5],
                'fill-extrusion-base': ['coalesce', ['get', 'min_height'], 0],
                'fill-extrusion-opacity': 0.8
              }
            });
          } else {
            acc.push(layer);
          }
          return acc;
        }, []);
      }

      return {
        version: 8,
        glyphs: 'https://protomaps.github.io/basemaps-assets/fonts/{fontstack}/{range}.pbf',
        sprite: 'https://protomaps.github.io/basemaps-assets/sprites/v4/' + flavorName,
        sources: {
          protomaps: {
            type: 'vector',
            url: 'pmtiles://' + PMTILES_URL,
            attribution: '\u00a9 <a href="https://openstreetmap.org">OpenStreetMap</a> · <a href="https://protomaps.com">Protomaps</a>'
          }
        },
        layers: layers
      };
    }

    // Initialize map with the default "light" flavor, centered on Stockholm
    var currentFlavor = 'light';
    var map = new maplibregl.Map({
      container: 'map',
      style: buildStyle(currentFlavor),
      center: [18.07, 59.33],
      zoom: 10
    });

    map.addControl(new maplibregl.NavigationControl());

    // --- Airports clustering overlay ---
    var airportsVisible = true;
    var AIRPORT_LAYERS = ['airport-clusters', 'airport-cluster-count', 'airport-unclustered'];

    function addAirportLayers() {
      if (!map.getSource('airports')) {
        map.addSource('airports', {
          type: 'geojson',
          data: '/data/airports.geojson',
          cluster: true,
          clusterMaxZoom: 14,
          clusterRadius: 50
        });
      }
      if (!map.getLayer('airport-clusters')) {
        map.addLayer({
          id: 'airport-clusters',
          type: 'circle',
          source: 'airports',
          filter: ['has', 'point_count'],
          paint: {
            'circle-color': ['step', ['get', 'point_count'],
              '#51bbd6', 20,
              '#2196F3', 50,
              '#1976D2', 100,
              '#1565C0', 250,
              '#0D47A1'
            ],
            'circle-radius': ['step', ['get', 'point_count'],
              15, 20, 20, 50, 25, 100, 30, 250, 35
            ]
          }
        });
        map.addLayer({
          id: 'airport-cluster-count',
          type: 'symbol',
          source: 'airports',
          filter: ['has', 'point_count'],
          layout: {
            'text-field': ['get', 'point_count_abbreviated'],
            'text-size': 12
          },
          paint: { 'text-color': '#ffffff' }
        });
        map.addLayer({
          id: 'airport-unclustered',
          type: 'circle',
          source: 'airports',
          filter: ['!', ['has', 'point_count']],
          paint: {
            'circle-color': ['match', ['get', 'type'], 'large', '#E65100', '#FB8C00'],
            'circle-radius': 5,
            'circle-stroke-width': 1,
            'circle-stroke-color': '#fff'
          }
        });
      }
      var vis = airportsVisible ? 'visible' : 'none';
      AIRPORT_LAYERS.forEach(function (id) {
        if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', vis);
      });
    }

    map.on('load', addAirportLayers);

    // Click cluster to zoom in
    map.on('click', 'airport-clusters', function (e) {
      var cluster = e.features[0];
      map.getSource('airports').getClusterExpansionZoom(cluster.properties.cluster_id, function (err, zoom) {
        if (err) return;
        map.easeTo({ center: cluster.geometry.coordinates, zoom: zoom });
      });
    });

    // Click unclustered airport for popup
    map.on('click', 'airport-unclustered', function (e) {
      var f = e.features[0];
      var p = f.properties;
      var label = (p.iata ? p.iata + ' / ' : '') + (p.icao || '');
      var html = '<strong>' + (p.name || 'Airport') + '</strong><br>' + label;
      if (p.municipality) html += '<br>' + p.municipality + ', ' + (p.country || '');
      new maplibregl.Popup().setLngLat(f.geometry.coordinates).setHTML(html).addTo(map);
    });

    map.on('mouseenter', 'airport-clusters', function () { map.getCanvas().style.cursor = 'pointer'; });
    map.on('mouseleave', 'airport-clusters', function () { map.getCanvas().style.cursor = ''; });
    map.on('mouseenter', 'airport-unclustered', function () { map.getCanvas().style.cursor = 'pointer'; });
    map.on('mouseleave', 'airport-unclustered', function () { map.getCanvas().style.cursor = ''; });

    // Feature inspector — click any feature to see its layer and properties
    map.on('click', function (e) {
      // Skip if an airport layer handled the click
      var airportHit = map.queryRenderedFeatures(e.point, { layers: AIRPORT_LAYERS.filter(function (id) { return map.getLayer(id); }) });
      if (airportHit.length > 0) return;

      var features = map.queryRenderedFeatures(e.point);
      if (features.length === 0) return;

      var feature = features[0];
      var props = feature.properties;
      var html = '<strong>' + feature.layer.id + '</strong><br>';
      for (var key in props) {
        if (props.hasOwnProperty(key)) {
          html += key + ': ' + props[key] + '<br>';
        }
      }

      new maplibregl.Popup()
        .setLngLat(e.lngLat)
        .setHTML(html)
        .addTo(map);
    });

    // Layer toggles
    var labelsVisible = true;
    var poisVisible = true;

    function setLayerVisibility(filter, visible) {
      var visibility = visible ? 'visible' : 'none';
      map.getStyle().layers.forEach(function (layer) {
        if (filter(layer)) {
          map.setLayoutProperty(layer.id, 'visibility', visibility);
        }
      });
    }

    document.getElementById('toggle-labels').addEventListener('change', function () {
      labelsVisible = this.checked;
      setLayerVisibility(function (layer) {
        return layer.type === 'symbol' && layer['source-layer'] !== 'pois';
      }, labelsVisible);
    });

    document.getElementById('toggle-pois').addEventListener('change', function () {
      poisVisible = this.checked;
      setLayerVisibility(function (layer) {
        return layer['source-layer'] === 'pois';
      }, poisVisible);
    });

    document.getElementById('toggle-airports').addEventListener('change', function () {
      airportsVisible = this.checked;
      var vis = airportsVisible ? 'visible' : 'none';
      AIRPORT_LAYERS.forEach(function (id) {
        if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', vis);
      });
    });

    document.getElementById('toggle-3d').addEventListener('change', function () {
      buildings3dEnabled = this.checked;
      applyStyle(currentFlavor);
    });

    // View controls
    var pitchSlider = document.getElementById('pitch-slider');
    var bearingSlider = document.getElementById('bearing-slider');

    document.querySelectorAll('#controls input[name="view"]').forEach(function (input) {
      input.addEventListener('change', function () {
        if (this.value === '3d') {
          map.easeTo({ pitch: 60, bearing: -20, duration: 800 });
          pitchSlider.value = 60;
          bearingSlider.value = 340;
        } else {
          map.easeTo({ pitch: 0, bearing: 0, duration: 800 });
          pitchSlider.value = 0;
          bearingSlider.value = 0;
        }
      });
    });

    pitchSlider.addEventListener('input', function () { map.setPitch(Number(this.value)); });
    bearingSlider.addEventListener('input', function () { map.setBearing(Number(this.value)); });
    map.on('pitchend', function () { pitchSlider.value = Math.round(map.getPitch()); });
    map.on('rotate', function () { bearingSlider.value = Math.round((map.getBearing() + 360) % 360); });

    // Style switcher — regenerate style and preserve map position
    function applyStyle(name) {
      currentFlavor = name;
      if (isApolloStyle(name)) {
        loadApolloStyle(name).then(function (style) {
          map.setStyle(style);
        });
      } else {
        map.setStyle(buildStyle(name));
      }
    }

    document.querySelectorAll('#controls input[name="style"]').forEach(function (input) {
      input.addEventListener('change', function () {
        applyStyle(this.value);
      });
    });

    // Re-apply toggle state and overlays after style switch
    map.on('styledata', function () {
      if (!labelsVisible) {
        setLayerVisibility(function (layer) {
          return layer.type === 'symbol' && layer['source-layer'] !== 'pois';
        }, false);
      }
      if (!poisVisible) {
        setLayerVisibility(function (layer) {
          return layer['source-layer'] === 'pois';
        }, false);
      }
      addAirportLayers();
    });
  </script>
</body>
</html>
